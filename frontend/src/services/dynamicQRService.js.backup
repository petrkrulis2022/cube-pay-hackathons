// Dynamic QR Service for AR Viewer
// Handles EVM network autodetection and QR generation
// Based on existing payment patterns from main branch

import {
  networkDetectionService,
  SUPPORTED_EVM_NETWORKS,
} from "./networkDetectionService";
import { formatInteractionFee } from "../utils/agentDataValidator";
import QRCode from "qrcode";

class DynamicQRService {
  constructor() {
    this.currentNetwork = null;
    // USDC token addresses for supported EVM testnets
    this.usdcTokenAddresses = {
      11155111: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238", // Ethereum Sepolia
      421614: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d", // Arbitrum Sepolia
      84532: "0x036CbD53842c5426634e7929541eC2318f3dCF7e", // Base Sepolia
      11155420: "0x5fd84259d66Cd46123540766Be93DFE6D43130D7", // OP Sepolia
      43113: "0x5425890298aed601595a70AB815c96711a31Bc65", // Avalanche Fuji
    };
  }

  async generateDynamicQR(agentData, amountUSD = null) {
    try {
      console.log(
        "üéØ CUBE QR INTEGRATION: Starting QR generation for agent:",
        agentData.id
      );
      console.log("üìä Agent deployment data:", {
        id: agentData.id,
        deployment_chain_id: agentData.deployment_chain_id,
        deployment_network_name: agentData.deployment_network_name,
        chain_id: agentData.chain_id,
        network: agentData.network,
        interaction_fee_amount: agentData.interaction_fee_amount,
        interaction_fee_token: agentData.interaction_fee_token,
        payment_recipient_address: agentData.payment_recipient_address,
        agent_wallet_address: agentData.agent_wallet_address,
        wallet_address: agentData.wallet_address,
        deployer_address: agentData.deployer_address,
        currency_type: agentData.currency_type,
        interaction_fee: agentData.interaction_fee,
      });

      // üîß CRITICAL: Use chain_id as primary (deployment_chain_id has wrong values)
      // Remove deployment_chain_id and deployment_network_name - they're incorrect
      const chainId = agentData.chain_id || agentData.deployment_chain_id;

      // Don't trust deployment_network_name - derive network from chain_id
      let networkName = "Unknown Network";
      if (chainId) {
        const networkMap = {
          11155111: "Ethereum Sepolia",
          421614: "Arbitrum Sepolia",
          84532: "Base Sepolia",
          11155420: "OP Sepolia",
          43113: "Avalanche Fuji",
        };
        networkName = networkMap[chainId] || "Unknown Network";
      }

      console.log("üîß CORRECTED QR Generation Data:");
      console.log(
        "- Using chain_id:",
        chainId,
        "(bypassing deployment_chain_id)"
      );
      console.log(
        "- Derived network:",
        networkName,
        "(bypassing deployment_network_name)"
      );
      console.log(
        "- Skipped deployment_chain_id:",
        agentData.deployment_chain_id
      );
      console.log(
        "- Skipped deployment_network_name:",
        agentData.deployment_network_name
      );

      // üîß Use EXACT same fee logic as AgentInteractionModal for consistency
      let feeAmount = 1; // fallback
      let feeToken = "USDC";
      let feeSource = "fallback";

      // PRIORITY 1: interaction_fee_amount (authoritative field)
      if (
        agentData?.interaction_fee_amount !== undefined &&
        agentData?.interaction_fee_amount !== null &&
        !isNaN(agentData?.interaction_fee_amount) &&
        agentData?.interaction_fee_amount > 0
      ) {
        feeAmount = parseFloat(agentData.interaction_fee_amount);
        feeToken = agentData?.interaction_fee_token || "USDC";
        feeSource = "interaction_fee_amount";
      }
      // PRIORITY 2: fee_usdc
      else if (
        agentData?.fee_usdc !== undefined &&
        agentData?.fee_usdc !== null &&
        !isNaN(agentData?.fee_usdc) &&
        agentData?.fee_usdc > 0
      ) {
        feeAmount = parseFloat(agentData.fee_usdc);
        feeToken = "USDC";
        feeSource = "fee_usdc";
      }
      // PRIORITY 3: fee_usdt
      else if (
        agentData?.fee_usdt !== undefined &&
        agentData?.fee_usdt !== null &&
        !isNaN(agentData?.fee_usdt) &&
        agentData?.fee_usdt > 0
      ) {
        feeAmount = parseFloat(agentData.fee_usdt);
        feeToken = "USDT";
        feeSource = "fee_usdt";
      }
      // PRIORITY 4: interaction_fee_usdfc (legacy)
      else if (
        agentData?.interaction_fee_usdfc !== undefined &&
        agentData?.interaction_fee_usdfc !== null &&
        !isNaN(agentData?.interaction_fee_usdfc) &&
        agentData?.interaction_fee_usdfc > 0
      ) {
        feeAmount = parseFloat(agentData.interaction_fee_usdfc);
        feeToken = "USDC";
        feeSource = "interaction_fee_usdfc";
      }
      // PRIORITY 5: interaction_fee (legacy)
      else if (
        agentData?.interaction_fee !== undefined &&
        agentData?.interaction_fee !== null &&
        !isNaN(agentData?.interaction_fee) &&
        agentData?.interaction_fee > 0
      ) {
        feeAmount = parseFloat(agentData.interaction_fee);
        feeToken = "USDC";
        feeSource = "interaction_fee";
      }

      const tokenAmount = amountUSD || feeAmount;

      console.log("üí∞ Using resolveInteractionFee priority logic:");
      console.log("- Amount:", tokenAmount, feeToken);
      console.log("- Source:", feeSource);
      console.log("- Modal compatibility: ‚úÖ");

      // 3. Use dynamic wallet address (NEW - with fallback to legacy)
      const recipientAddress =
        agentData.payment_config?.wallet_address ||
        agentData.wallet_address ||
        agentData.deployer_address ||
        agentData.payment_recipient_address;

      console.log("üåê Using corrected deployment data:");
      console.log("- Agent ID:", agentData.id);
      console.log("- Network:", networkName, "(Chain ID:", chainId + ")");
      console.log("- Interaction Fee:", tokenAmount, feeToken);
      console.log("- Recipient Wallet:", recipientAddress);
      console.log("- Has Payment Config:", !!agentData.payment_config);

      if (!recipientAddress) {
        console.error("‚ùå NO WALLET ADDRESS FOUND:");
        console.error(
          "- payment_config?.wallet_address:",
          agentData.payment_config?.wallet_address
        );
        console.error("- wallet_address:", agentData.wallet_address);
        console.error("- deployer_address:", agentData.deployer_address);
        console.error(
          "- payment_recipient_address:",
          agentData.payment_recipient_address
        );
        console.error(
          "- agent_wallet_address:",
          agentData.agent_wallet_address
        );
        throw new Error(
          "Agent wallet address not found - cannot generate payment QR"
        );
      }

      // Detect user's current network
      const userNetwork = await networkDetectionService.detectCurrentNetwork();

      if (!userNetwork || userNetwork.isSupported === false) {
        throw new Error(
          "Please switch to a supported network to make payments"
        );
      }

      console.log(
        "üîç User network:",
        userNetwork.name,
        "Chain ID:",
        userNetwork.chainId
      );

      // CRITICAL FIX: Use agent's corrected chain ID instead of user's network
      // The QR code should always be for the agent's deployment network
      let targetChainId = chainId;
      let targetNetworkName = networkName;

      // Only fall back to user network if agent has no deployment data
      if (!targetChainId || !this.isNetworkSupported(targetChainId)) {
        console.warn(
          `‚ö†Ô∏è Agent has no valid deployment network data. Using user's network: ${userNetwork.name} (${userNetwork.chainId})`
        );
        targetChainId = userNetwork.chainId;
        targetNetworkName = userNetwork.name;
      }

      // Validate network compatibility (warn but don't block)
      if (chainId && userNetwork.chainId !== chainId) {
        console.warn(
          `‚ö†Ô∏è Network mismatch: Agent deployed on ${networkName} (${chainId}), user on ${userNetwork.name} (${userNetwork.chainId})`
        );
        console.warn(
          "üéØ QR will be generated for agent's deployment network:",
          targetNetworkName
        );
      }

      console.log(
        "üéØ Target network for QR generation:",
        targetNetworkName,
        "Chain ID:",
        targetChainId
      );

      // Get USDC token address for target network
      const usdcAddress = this.usdcTokenAddresses[targetChainId];
      if (!usdcAddress) {
        throw new Error(
          `USDC not supported on network ${targetChainId} (${targetNetworkName})`
        );
      }

      console.log(
        "üí∞ Using USDC contract:",
        usdcAddress,
        "for",
        targetNetworkName
      );

      // Calculate final amount in token units
      let finalTokenAmount = tokenAmount;
      let tokenDecimals = 6; // Default USDC decimals

      // Adjust for different tokens
      if (feeToken === "USDT" || feeToken === "USDC") {
        tokenDecimals = 6;
      } else if (feeToken === "USBDG+" || feeToken === "USDFC") {
        tokenDecimals = 18; // Assuming 18 decimals for custom tokens
      }

      const tokenAmountWei = this.toTokenUnits(finalTokenAmount, tokenDecimals);

      console.log("üí∞ Payment details:");
      console.log("- Amount:", finalTokenAmount, feeToken);
      console.log("- Amount (wei):", tokenAmountWei);
      console.log("- Recipient:", recipientAddress);
      console.log("- Token contract:", usdcAddress);
      console.log("- Target network:", targetChainId);

      // Generate payment transaction data (EIP-681 format)
      const paymentData = {
        chainId: targetChainId,
        to: usdcAddress, // Token contract address
        data: this.encodeUSDCTransfer(recipientAddress, tokenAmountWei),
        value: "0", // No ETH value for ERC-20 transfers
        gasLimit: "100000", // Estimated gas limit for token transfer
      };

      // Generate EIP-681 format payment URI
      const eip681URI = this.generateEIP681URI(paymentData);
      console.log("üì± Generated EIP-681 URI:", eip681URI);

      // Generate QR code image
      const qrCodeUrl = await this.generateQRCodeImage(eip681URI);

      return {
        qrCodeUrl: qrCodeUrl,
        paymentData: paymentData,
        eip681URI: eip681URI,
        networkInfo: {
          chainId: targetChainId,
          name: targetNetworkName,
          blockExplorer: this.getBlockExplorerForChain(targetChainId),
        },
        tokenInfo: {
          address: usdcAddress,
          symbol: feeToken,
          decimals: tokenDecimals,
          amount: finalTokenAmount,
        },
        recipientAddress: recipientAddress,
        agentInfo: {
          id: agentData.id,
          name: agentData.name,
          // ‚úÖ Use corrected network data (removed deployment_* fields)
          networkName: networkName,
          chainId: chainId,
          hasDynamicData: !!(
            agentData.chain_id || agentData.interaction_fee_amount
          ),
          note: "Using chain_id instead of deployment_chain_id",
        },
      };
    } catch (error) {
      console.error("‚ùå Failed to generate dynamic QR:", error);
      throw error;
    }
  }

  // Generate EIP-681 format URI for wallet compatibility (IMPROVED)
  generateEIP681URI(paymentData) {
    const { chainId, to, data } = paymentData;

    // Parse the encoded transfer data to extract recipient and amount
    const recipient = "0x" + data.slice(34, 74); // Extract recipient from data
    const amount = "0x" + data.slice(74, 138); // Extract amount from data

    // Standard EIP-681 format for token transfers:
    // ethereum:<contract>@<chainId>/transfer?address=<recipient>&uint256=<amount>
    const uri = `ethereum:${to}@${chainId}/transfer?address=${recipient}&uint256=${parseInt(
      amount,
      16
    )}`;

    console.log("üîó Generated EIP-681 URI:", uri);
    console.log("üìä URI components:");
    console.log("- Contract:", to);
    console.log("- Chain ID:", chainId);
    console.log("- Recipient:", recipient);
    console.log("- Amount (decimal):", parseInt(amount, 16));

    return uri;
  }

  // Encode USDC transfer function call
  encodeUSDCTransfer(recipientAddress, amount) {
    // ERC-20 transfer function signature: transfer(address,uint256)
    const functionSignature = "0xa9059cbb";

    // Remove '0x' prefix and pad to 32 bytes (64 hex characters)
    const paddedRecipient = recipientAddress
      .slice(2)
      .toLowerCase()
      .padStart(64, "0");

    // Convert amount to hex and pad to 32 bytes
    const paddedAmount = amount.toString(16).padStart(64, "0");

    return functionSignature + paddedRecipient + paddedAmount;
  }

  // Convert decimal amount to token units (considering decimals)
  toTokenUnits(amount, decimals) {
    return Math.floor(amount * Math.pow(10, decimals));
  }

  // Generate QR code image from data
  async generateQRCodeImage(data) {
    try {
      const qrCodeDataURL = await QRCode.toDataURL(data, {
        width: 300,
        margin: 2,
        color: {
          dark: "#000000",
          light: "#FFFFFF",
        },
      });

      return qrCodeDataURL;
    } catch (error) {
      console.error("‚ùå QR code generation failed:", error);
      throw new Error("Failed to generate QR code image");
    }
  }

  // Execute payment transaction (based on existing paymentProcessor patterns)
  async executePayment(qrData) {
    if (!qrData || !qrData.paymentData) {
      throw new Error("No payment data available");
    }

    try {
      console.log("üí≥ Executing USDC payment...");

      // Check if wallet is connected
      if (!window.ethereum) {
        throw new Error("Please install MetaMask to make payments");
      }

      const accounts = await window.ethereum.request({
        method: "eth_accounts",
      });
      if (accounts.length === 0) {
        throw new Error("Please connect your wallet first");
      }

      // Verify user is on correct network
      const currentChainId = await window.ethereum.request({
        method: "eth_chainId",
      });
      const numericChainId = parseInt(currentChainId, 16);

      if (numericChainId !== qrData.paymentData.chainId) {
        throw new Error(
          `Please switch to ${qrData.networkInfo.name} to complete payment`
        );
      }

      console.log("üîê Requesting wallet signature...");

      // Execute the payment transaction
      const transactionHash = await window.ethereum.request({
        method: "eth_sendTransaction",
        params: [
          {
            from: accounts[0],
            to: qrData.paymentData.to,
            data: qrData.paymentData.data,
            value: qrData.paymentData.value,
            gas: `0x${parseInt(qrData.paymentData.gasLimit).toString(16)}`,
          },
        ],
      });

      console.log("‚úÖ Payment transaction sent:", transactionHash);

      // Wait for transaction confirmation (optional)
      const receipt = await this.waitForTransaction(transactionHash);

      return {
        transactionHash,
        receipt,
        amount: qrData.tokenInfo.amount,
        token: qrData.tokenInfo.symbol,
        network: qrData.networkInfo.name,
        recipient: qrData.recipientAddress,
        explorerUrl: `${qrData.networkInfo.blockExplorer}/tx/${transactionHash}`,
      };
    } catch (error) {
      console.error("‚ùå Payment execution failed:", error);

      if (error.code === 4001) {
        throw new Error("Payment cancelled by user");
      } else if (error.code === -32000) {
        throw new Error("Insufficient funds for transaction");
      } else {
        throw new Error(`Payment failed: ${error.message}`);
      }
    }
  }

  // Wait for transaction to be mined (similar to existing implementation)
  async waitForTransaction(txHash, timeout = 60000) {
    const startTime = Date.now();

    while (Date.now() - startTime < timeout) {
      try {
        const receipt = await window.ethereum.request({
          method: "eth_getTransactionReceipt",
          params: [txHash],
        });

        if (receipt) {
          console.log("‚úÖ Transaction confirmed:", receipt);
          return receipt;
        }

        // Wait 2 seconds before checking again
        await new Promise((resolve) => setTimeout(resolve, 2000));
      } catch (error) {
        console.error("Error checking transaction status:", error);
      }
    }

    throw new Error("Transaction confirmation timeout");
  }

  // Validate agent data completeness and network compatibility
  validateAgentData(agent) {
    const validation = {
      hasLegacyData: !!(
        agent.chain_id &&
        agent.network &&
        agent.interaction_fee
      ),
      hasDynamicData: !!(
        agent.deployment_chain_id &&
        agent.deployment_network_name &&
        agent.interaction_fee_amount
      ),
      hasPaymentConfig: !!(
        agent.payment_config && agent.payment_config.wallet_address
      ),
      hasWalletAddress: !!(
        agent.wallet_address ||
        agent.payment_config?.wallet_address ||
        agent.deployer_address
      ),
      isComplete: false,
      dataSource: "unknown",
    };

    // Determine data source and completeness
    if (validation.hasDynamicData) {
      validation.dataSource = "dynamic";
      validation.isComplete = !!(
        agent.deployment_chain_id &&
        agent.deployment_network_name &&
        agent.interaction_fee_amount &&
        validation.hasWalletAddress
      );
    } else if (validation.hasLegacyData) {
      validation.dataSource = "legacy";
      validation.isComplete = !!(
        agent.chain_id &&
        agent.network &&
        agent.interaction_fee &&
        validation.hasWalletAddress
      );
    }

    console.log("üìä Agent data validation:", validation);
    return validation;
  }

  // Validate network compatibility between agent and user
  validateNetworkCompatibility(agent, userNetwork) {
    // Use dynamic deployment data with fallback to legacy
    const agentChainId = agent.deployment_chain_id || agent.chain_id;
    const agentNetworkName = agent.deployment_network_name || agent.network;

    if (!agentChainId) {
      return {
        compatible: false,
        message: "Agent deployment network information is missing",
        severity: "error",
      };
    }

    if (agentChainId !== userNetwork.chainId) {
      return {
        compatible: false,
        message: `This agent is deployed on ${agentNetworkName} (Chain ${agentChainId}). Please switch to this network to interact.`,
        severity: "warning",
        requiredNetwork: {
          chainId: agentChainId,
          name: agentNetworkName,
          rpcUrl: agent.payment_config?.network_info?.rpcUrl,
        },
        userNetwork: {
          chainId: userNetwork.chainId,
          name: userNetwork.name,
        },
      };
    }

    return {
      compatible: true,
      message: `Networks compatible: ${agentNetworkName}`,
      severity: "success",
    };
  }

  // Get comprehensive agent payment configuration
  getAgentPaymentConfig(agent) {
    return {
      // Use dynamic fields with fallback to legacy
      chainId: agent.deployment_chain_id || agent.chain_id,
      networkName: agent.deployment_network_name || agent.network,
      interactionFee: agent.interaction_fee_amount || agent.interaction_fee,
      feeToken: agent.interaction_fee_token || agent.currency_type || "USDC",

      // Wallet addresses (prioritize payment config)
      walletAddress:
        agent.payment_config?.wallet_address ||
        agent.wallet_address ||
        agent.deployer_address ||
        agent.payment_recipient_address,

      // Token and network info
      tokenAddress: agent.token_address,
      networkConfig: agent.payment_config?.network_info,

      // Metadata
      supportedTokens: agent.payment_config?.supported_tokens || [
        agent.interaction_fee_token || agent.currency_type || "USDC",
      ],
      deploymentStatus: agent.deployment_status || "active",
      deployedAt: agent.deployed_at || agent.created_at,

      // Data source tracking
      isUsingDynamicData: !!(
        agent.deployment_chain_id || agent.interaction_fee_amount
      ),
      dataCompleteness: this.validateAgentData(agent),
    };
  }

  // Validate network support
  isNetworkSupported(chainId) {
    return Object.keys(this.usdcTokenAddresses).includes(chainId.toString());
  }

  // Get supported networks info
  getSupportedNetworks() {
    return Object.values(SUPPORTED_EVM_NETWORKS);
  }

  // Get block explorer URL for a specific chain
  getBlockExplorerForChain(chainId) {
    const explorers = {
      11155111: "https://sepolia.etherscan.io", // Ethereum Sepolia
      421614: "https://sepolia-explorer.arbitrum.io", // Arbitrum Sepolia
      84532: "https://sepolia-explorer.base.org", // Base Sepolia
      11155420: "https://sepolia-optimistic.etherscan.io", // OP Sepolia
      43113: "https://testnet.snowtrace.io", // Avalanche Fuji
      2810: "https://explorer-holesky.morphl2.io", // Morph Holesky
    };
    return explorers[chainId] || "https://etherscan.io";
  }

  // Main generateQR method for Cube integration
  async generateQR(agentData, amountUSD = null) {
    console.log("üéØ CUBE QR: generateQR called with agent:", agentData?.id);

    const result = await this.generateDynamicQR(agentData, amountUSD);

    // Make QR code clickable for direct transactions
    return {
      ...result,
      clickable: true,
      scannable: true,
      onClick: () => this.handleQRClick(result.paymentData),
    };
  }

  // Handle QR code click to trigger transaction
  async handleQRClick(paymentData) {
    console.log("üî• QR CLICKED: Triggering transaction:", paymentData);

    try {
      // Check if MetaMask is available
      if (!window.ethereum) {
        throw new Error("MetaMask not detected. Please install MetaMask.");
      }

      // Request account access
      await window.ethereum.request({ method: "eth_requestAccounts" });

      // Switch to correct network if needed
      const currentChainId = await window.ethereum.request({
        method: "eth_chainId",
      });
      const targetChainId = `0x${paymentData.chainId.toString(16)}`;

      if (currentChainId !== targetChainId) {
        console.log(`üîÑ Switching to chain ${targetChainId}`);
        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: targetChainId }],
          });
        } catch (switchError) {
          console.error("Network switch failed:", switchError);
          throw new Error(
            `Please switch to the correct network (Chain ID: ${paymentData.chainId})`
          );
        }
      }

      // Send transaction
      const transactionHash = await window.ethereum.request({
        method: "eth_sendTransaction",
        params: [
          {
            to: paymentData.to,
            data: paymentData.data,
            value: paymentData.value || "0x0",
            gas: `0x${parseInt(paymentData.gasLimit).toString(16)}`,
          },
        ],
      });

      console.log("‚úÖ Transaction sent:", transactionHash);
      return {
        success: true,
        transactionHash,
        message: "Transaction submitted successfully!",
      };
    } catch (error) {
      console.error("‚ùå Transaction failed:", error);
      return {
        success: false,
        error: error.message,
        message: "Transaction failed: " + error.message,
      };
    }
  }

export const dynamicQRService = new DynamicQRService();
export default dynamicQRService;
